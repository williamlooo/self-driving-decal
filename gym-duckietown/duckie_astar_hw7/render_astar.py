#!/usr/bin/env python


"""
This script applies A* to plan paths to randomly sampled goals using the previously rendered costmap.

If you have not already, complete the script render_costmap.py
A* is a graph search algorithm that enables the optimal path to be found between two points that mimizes cost.
We control the cost by assigning positive weights to the graph edges.
These weights are calculated using the costmap generated by render_costmap.py
In this script you will be using an implementation of A* using the networkx library.

test your implementation with the following command:
python duckie_astar_hw7/render_astar.py --infile "costmap.png" --outfile "plan.png"

This script renders to the screen, which you need to record and include in your checkoff submission.
"""


import argparse
import cv2
import numpy as np
import networkx
import sys
sys.path.append("/Users/williamloo/selfdriving-fa19/gym-duckietown")
from gym_duckietown.envs import DuckietownEnv

#sys.path.append("/PID-homework")
class PID:
    def __init__(self, proportional = 0, integral = 0, derivative = 0):
        '''
        Initialize the constants and any other variables you need
        '''
        self.prev_error = 0
        self.total_error = 0
        self.derivative = derivative 
        self.integral = integral
        self.proportional = proportional
        self.sign_change = False

    def update(self, error):
        #print(self.prev_error)
        delT = 0.03333333333
        delE = error - self.prev_error
        if self.prev_error < 0 and error > 0 or self.prev_error > 0 and error < 0:
            self.sign_change = True
        self.prev_error = error

        self.total_error+=delT*delE

        '''
        We have given two values here to start with: the change in T as calculated by framerate (which is update rate) and the other,
        which has not yet been defined, which is the change in error from last time.
        '''
        if abs(error) < 1e-3 or self.sign_change == True:
            error = 0
            self.sign_change = False

        output = self.derivative*delE + self.integral*self.total_error

        return output



def astar(start, end, costmap):

    def distance(node1, node2):
        return np.sqrt(np.square(node1[0] - node2[0]) + np.square(
            node1[1] - node2[1]))
    graph = networkx.grid_2d_graph(costmap.shape[1], costmap.shape[0])
    for node1, node2, edge in graph.edges(data=True):
        edge['weight'] = 999999 * (1.0 - costmap[node1[1], node1[0]])
        edge['weight'] = 999999 * (1.0 - costmap[node2[1], node2[0]])
    return networkx.astar_path(
        graph, (start[0], start[1]), (end[0], end[1]), distance)


if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument('--env-name', default=None)
    parser.add_argument('--map-name', default='udem1')
    parser.add_argument('--distortion', default=False, action='store_true')
    parser.add_argument('--draw-curve', action='store_true', help='draw the lane following curve')
    parser.add_argument('--draw-bbox', action='store_true', help='draw collision detection bounding boxes')
    parser.add_argument('--domain-rand', action='store_true', help='enable domain randomization')
    parser.add_argument('--frame-skip', default=1, type=int, help='number of frames to skip')
    parser.add_argument('--seed', default=1, type=int, help='seed')
    parser.add_argument('--transform', default="transform.npy", type=str)
    parser.add_argument('--infile', default="costmap.png", type=str)
    parser.add_argument('--outfile', default="plan.png", type=str)
    args = parser.parse_args()

    env = DuckietownEnv(
        seed=args.seed,
        map_name=args.map_name,
        draw_curve=args.draw_curve,
        draw_bbox=args.draw_bbox,
        domain_rand=args.domain_rand,
        frame_skip=args.frame_skip,
        distortion=args.distortion,
        do_color_relabeling=False)

    env.reset()
    orig = env.render(mode="top_down")

    transform = np.load(args.transform)
    car_pos = (env.cur_pos[::2] / transform[0] + transform[1:])
    car_pos = (int(car_pos[0]), int(car_pos[1]))
    car_angle = env.cur_angle

    costmap = cv2.imread(args.infile, cv2.IMREAD_UNCHANGED).astype(float) / 255.0

    height = costmap.shape[0]
    width = costmap.shape[1]
    coords = np.stack(np.meshgrid(np.arange(width), np.arange(height)), axis=2)

    """BEGIN YOUR CODE"""

    # randomly sample a position for the car to navigate to in image coordinates.
    cv2.imshow("c", costmap)
    cv2.waitKey(500)
    #while not satisfied:
    #    end_pos = (np.random.normal(costmap),np.random.normal(costmap))
    #end_pos = (2,2)
    #end_pos = np.random.sample()
    satisfied=False
    """
    while not satisfied:
        x = np.random.sample(width)
        y = np.random.sample(height)

        #x = int(x)
        #y = int(y)


        if costmap[x][y] == 1:
            satisfied = True

    print(costmap[x][y])
    end_pos = (x,y)
    """
    frame=cv2.UMat(top_down_environment)
    end_pos = (3,3)
    print(end_pos)
    print("COSTMAP")
    print(costmap)

    # call the function astar using teh starting position of the car in image coordinates
    # the goal you sampled, and also the costmap

    # assign the result to the variable trajectory

    # render the trajectory visibly superimposed on a rendered image of the duckietown sim
    # save this result to args.outfile
    

    trajectory = astar(car_pos, end_pos, costmap)
    for pt in trajectory:
        print(orig[pt[0]][pt[1]])
        orig[pt[0]][pt[1]] = (255,255,255)
    cv2.imshow("orig",orig)
    """END YOUR CODE"""

    input("wrote plan to {}, press enter to continue...".format(args.outfile))

    current_goal = trajectory.pop(0)
    while len(trajectory) > 0:
        car_position = (env.cur_pos[::2] / transform[0] + transform[1:])
        car_angle = env.cur_angle

        while car_angle < 0:
            car_angle += 2 * np.pi

        while car_angle > 2 * np.pi:
            car_angle -= 2 * np.pi

        direction_of_goal = np.array(current_goal) - car_position
        distance_to_goal = np.linalg.norm(direction_of_goal, ord=2)

        if distance_to_goal < 35:
            current_goal = trajectory.pop(0)
            continue

        angle_to_goal = np.arctan2(-direction_of_goal[1], direction_of_goal[0])
        angle_to_goal = angle_to_goal if angle_to_goal > 0 else 2 * np.pi + angle_to_goal

        while angle_to_goal < 0:
            angle_to_goal += 2 * np.pi

        while angle_to_goal > 2 * np.pi:
            angle_to_goal -= 2 * np.pi

        angle_offset = angle_to_goal - car_angle

        """BEGIN YOUR CODE"""

        # using your PID controller from the previous homework
        # devise a control scheme for enabling the duckie bot car to follow the "current_goal"
        lane_pose = env.get_lane_pos2(env.cur_pos, env.cur_angle)
        e_p = lane_pose.dist
        new_pid = PID(20,2,2)
        pid_output = new_pid.update(e_p)
        steer = pid_output
        print(steer)
        #steer = 0.3
        action = np.array([.4, steer])

        obs, reward, done, info = env.step(action)
        # assign this result to the variable action

        """END YOUR CODE"""

        env.step(action)

        env.render(mode="top_down")
